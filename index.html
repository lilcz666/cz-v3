<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Gemini V5 [Original Core]</title>
    <style>
        :root {
            --bg-color: #e0e5ec;
            --text-main: #4a4a4a;
            --text-sub: #8792a3;
            --shadow-light: -9px -9px 16px rgba(255,255,255, 0.8);
            --shadow-dark: 9px 9px 16px rgba(163,177,198, 0.6);
            --radius: 20px;
            
            --c-red: #e03e3e;
            --c-green: #2ecc71;
            --c-blue: #3498db;
            --c-gold: #f1c40f;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 420px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* 顶部状态栏 */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: var(--text-sub);
            padding: 0 10px;
        }
        .live-dot {
            width: 8px; height: 8px; 
            background: #ccc; border-radius: 50%;
            display: inline-block; margin-right: 5px;
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.2);
        }
        .live-dot.active { background: var(--c-green); box-shadow: 0 0 8px var(--c-green); }

        /* 新拟态卡片通用样式 */
        .neu-card {
            background: var(--bg-color);
            border-radius: var(--radius);
            box-shadow: var(--shadow-dark), var(--shadow-light);
            padding: 20px;
            position: relative;
        }
        .neu-inset {
            border-radius: 12px;
            box-shadow: inset 6px 6px 10px rgba(163,177,198, 0.6), inset -6px -6px 10px rgba(255,255,255, 0.8);
            padding: 15px;
            background: #e0e5ec;
        }

        /* 核心预测大圆盘 */
        .main-prediction {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .circle-outer {
            width: 160px; height: 160px;
            border-radius: 50%;
            box-shadow: var(--shadow-dark), var(--shadow-light);
            display: flex; 
            align-items: center; 
            justify-content: center;
            margin: 10px 0 20px 0;
        }
        .circle-inner {
            width: 120px; height: 120px;
            border-radius: 50%;
            box-shadow: inset 6px 6px 10px rgba(163,177,198, 0.6), inset -6px -6px 10px rgba(255,255,255, 0.8);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .res-text { font-size: 2.5rem; font-weight: 800; line-height: 1; }
        .res-conf { font-size: 0.7rem; margin-top: 5px; color: var(--text-sub); }

        .red-t { color: var(--c-red); }
        .green-t { color: var(--c-green); }

        /* 算法矩阵看板 (第12段要求) */
        .matrix-table {
            width: 100%;
            font-size: 0.75rem;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .matrix-table td { padding: 6px; text-align: center; border-bottom: 1px solid rgba(0,0,0,0.05); }
        .matrix-table th { padding: 6px; color: var(--text-sub); font-weight: 600; font-size: 0.7rem; }
        
        /* 逻辑深度解析区 */
        .analysis-text {
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--text-main);
            white-space: pre-wrap;
            text-align: left;
        }
        .section-title {
            font-size: 0.85rem; font-weight: 700; 
            color: var(--c-blue); margin-bottom: 8px;
            display: flex; align-items: center;
        }
        .section-title::before {
            content: ''; width: 4px; height: 14px; background: var(--c-blue);
            margin-right: 8px; border-radius: 2px;
        }

        /* 历史列表 */
        .history-row {
            display: flex; justify-content: space-between;
            padding: 10px 0; border-bottom: 1px solid rgba(0,0,0,0.05);
            font-size: 0.8rem;
        }
        .badge {
            padding: 2px 6px; border-radius: 6px; font-weight: 700; font-size: 0.7rem;
        }
        .b-red { background: rgba(224,62,62,0.1); color: var(--c-red); }
        .b-green { background: rgba(46,204,113,0.1); color: var(--c-green); }

        /* 倒计时条 */
        .progress-line {
            height: 3px; background: var(--c-blue); width: 0%;
            transition: width 0.2s linear; border-radius: 2px;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="status-bar">
            <div><span id="dot" class="live-dot"></span><span id="sysState">初始化系统...</span></div>
            <div id="nextTimer">--s</div>
        </div>

        <div class="neu-card main-prediction">
            <div style="font-size:0.9rem; font-weight:600;">第 <span id="targetIssue" style="color:var(--c-blue)">--</span> 期 核心战令</div>
            <div class="circle-outer">
                <div class="circle-inner">
                    <div id="finalRes" class="res-text">--</div>
                    <div id="finalConf" class="res-conf">WAITING</div>
                </div>
            </div>
            <div id="scoreBoard" style="display:flex; gap:15px; font-size:0.8rem; color:var(--text-main);">
                <span>大:<b id="sBig">0</b></span>
                <span>小:<b id="sSml">0</b></span>
                <span>单:<b id="sOdd">0</b></span>
                <span>双:<b id="sEvn">0</b></span>
            </div>
            <div class="progress-line" id="progressBar"></div>
        </div>

        <div class="neu-card">
            <div class="section-title">算法矩阵看板 (V5.0全量)</div>
            <div class="neu-inset">
                <table class="matrix-table">
                    <thead>
                        <tr><th>算法ID</th><th>D位/结果</th><th>判定</th><th>权限</th></tr>
                    </thead>
                    <tbody id="matrixBody">
                        </tbody>
                </table>
            </div>
        </div>

        <div class="neu-card">
            <div class="section-title">逻辑深度解析 & 战术路径</div>
            <div id="analysisBox" class="analysis-text">
                等待数据喂养...
            </div>
        </div>

        <div class="neu-card">
            <div class="section-title">历史复盘 & 准星校准</div>
            <div id="historyList" style="max-height: 250px; overflow-y: auto;">
                </div>
        </div>
    </div>

<script>
    // --- V5.0 终极常量与配置 ---
    const CONFIG = {
        api: "https://pc28.help/kj.json?limit=50", 
        refreshInterval: 20, // 20秒一刷
        timer: null,
        count: 20,
        history: [] // 本地存储
    };

    // --- 第 1-10 段：核心算法库 ---
    const MATH = {
        // 算法16: 几何震荡 (P1)
        algo16: (n1, n2) => {
            let val = Math.sqrt(n1 * n2 * (1 + Math.abs(n1 - n2) / 28.5) + 7.5515);
            let d = parseInt(val.toFixed(6).split('.')[1][0]);
            let dir = d >= 5 ? '大' : '小'; // 简单映射，后续有冲突管理
            return { id: 16, val: val, d: d, dir: dir, p: 'P1' };
        },
        // 算法14: 单双裂变 (P1)
        algo14: (n1, n2, n3, n4) => {
            let val = Math.sqrt(Math.pow((n1 - n2), 2) + (Math.pow(n3, 2) / (n4 + 1)) + 1.6180);
            let d = parseInt(val.toFixed(6).split('.')[1][0]);
            let dir = (d >= 0 && d <= 4) ? '同(顺)' : '反(裂)'; // 0-4顺, 5-9裂
            return { id: 14, val: val, d: d, dir: dir, p: 'P1' };
        },
        // 算法19: 手术刀 (P0) - 核心
        algo19: (n1, n2, n3) => {
            let val = (Math.sqrt(n1**2 + n2**2 + n3**2)) / 3.81966;
            let d = parseInt(val.toFixed(6).split('.')[1][0]);
            let i = Math.floor(val);
            let size = '中';
            if ([0,1,2].includes(d)) size = '小';
            if ([7,8,9].includes(d)) size = '大';
            
            // 混沌纠缠区 I-熵判定 (第6段)
            let oe = '无';
            if ([3,4,5,6].includes(d)) {
                oe = ((i + n1 + n2) % 3 === 0) ? '单' : '双';
            }
            return { id: 19, val: val, d: d, dir: size + (oe!=='无'?'|'+oe:''), p: 'P0' };
        },
        // 算法18: 三角动量 (P2)
        algo18: (n1, n2, n3) => {
            let val = ((n1 + 3.1415) * (n2 + 2.7182) * (n3 + 1.4142)) / 42.75;
            let d = parseInt(val.toFixed(6).split('.')[1][0]);
            let u = Math.floor(val) % 10;
            return { id: 18, val: val, d: d, dir: (d>=5?'大':'小')+'|'+(u%2!==0?'单':'双'), p: 'P2' };
        },
        // 算法2: 黄金反向 (P3)
        algo2: (n1) => {
            let val = (n1 + 0.61803) * 0.61803;
            let i = Math.floor(val);
            // 偶数买单，奇数买双
            return { id: 2, val: val, d: 0, dir: (i%2===0)?'单':'双', p: 'P3' };
        },
        // 算法3: 变盘预警 (P3)
        algo3: (n1, n2, n3) => {
            let val = (n1 + n2 + n3) / 6.6666;
            let str = val.toFixed(6);
            let d = parseInt(str.split('.')[1][0]);
            let dir = '中';
            if ([1,2,4,8].includes(d)) dir = '小';
            if ([3,5,7,9].includes(d)) dir = '大';
            if (d === 0 || d === 6) dir = '警(反)'; // 变盘
            return { id: 3, val: val, d: d, dir: dir, p: 'P3' };
        },
        // 算法10: 极值修正 (P4)
        algo10: (n4) => {
            let val = 280 / (n4 + 2.2222);
            let dec = val - Math.floor(val);
            let dir = '震荡';
            if (dec < 0.333) dir = '反弹';
            if (dec > 0.666) dir = '延续';
            return { id: 10, val: val, d: dec.toFixed(2), dir: dir, p: 'P4' };
        }
    };

    // --- 系统核心逻辑 ---
    
    // 拉取数据（带防缓存）
    async function fetchData() {
        const domDot = document.getElementById('dot');
        const domState = document.getElementById('sysState');
        
        domDot.classList.add('active');
        domState.innerText = "正在通过 V5 隧道同步...";

        try {
            // 加时间戳防止缓存
            const t = new Date().getTime();
            const proxy = 'https://api.allorigins.win/get?url=' + encodeURIComponent(CONFIG.api + "&_t=" + t);
            
            const res = await fetch(proxy);
            const json = await res.json();
            
            if (!json.contents) throw new Error("代理无响应");
            const raw = JSON.parse(json.contents);
            
            if (!raw.data || raw.data.length === 0) throw new Error("源数据为空");

            // 数据处理：合并去重
            // API 是最新的在前。
            let newDataList = raw.data.map(item => {
                const parts = item.opennum.split('+');
                return {
                    q: item.qihao,
                    n1: parseInt(parts[0]),
                    n2: parseInt(parts[1]),
                    n3: parseInt(parts[2]),
                    sum: parseInt(item.sum),
                    t: item.opentime
                };
            }).reverse(); // 转为旧->新，方便处理趋势

            // 更新本地历史
            let hasUpdate = false;
            newDataList.forEach(item => {
                if (!CONFIG.history.find(h => h.q === item.q)) {
                    CONFIG.history.push(item);
                    hasUpdate = true;
                }
            });
            
            // 保持最近 60 期
            if (CONFIG.history.length > 60) CONFIG.history = CONFIG.history.slice(-60);

            if (hasUpdate) {
                domState.innerText = "数据已更新，执行运算...";
                runV5Engine(); // 核心运算入口
            } else {
                domState.innerText = "数据未变，等待下期...";
            }

        } catch (e) {
            console.error(e);
            domState.innerText = "同步失败，重试中...";
        } finally {
            setTimeout(() => domDot.classList.remove('active'), 500);
            resetTimer();
        }
    }

    // --- 核心运算引擎 (第11-14段) ---
    function runV5Engine() {
        // 取最新一期作为“上一期”依据，预测下一期
        const last = CONFIG.history[CONFIG.history.length - 1];
        const prev = CONFIG.history[CONFIG.history.length - 2]; // 上上期，用于比较趋势
        
        // 下一期期号
        const nextIssue = BigInt(last.q) + 1n;
        document.getElementById('targetIssue').innerText = nextIssue;

        // 1. 运行算法矩阵
        const r19 = MATH.algo19(last.n1, last.n2, last.n3);
        const r16 = MATH.algo16(last.n1, last.n2);
        const r14 = MATH.algo14(last.n1, last.n2, last.n3, last.sum);
        const r18 = MATH.algo18(last.n1, last.n2, last.n3);
        const r2 = MATH.algo2(last.n1);
        const r3 = MATH.algo3(last.n1, last.n2, last.n3);
        const r10 = MATH.algo10(last.sum);

        const matrix = [r19, r16, r14, r18, r2, r3, r10];

        // 2. 动态冲突管理 (第11段)
        let w = { big: 0, sml: 0, odd: 0, evn: 0 };
        let log = ""; // 逻辑解析文本

        // 2.1 状态检测
        let isDragon = false; // 龙局检测 (需遍历历史，此处简化)
        let isDiving = Math.abs(last.n1 - last.n2) > 8; // 跳水状态

        // 2.2 权重计算
        // Algo 19 (P0)
        if (r19.dir.includes('大')) w.big += 10;
        if (r19.dir.includes('小')) w.sml += 10;
        if (r19.dir.includes('单')) w.odd += 10;
        if (r19.dir.includes('双')) w.evn += 10;
        log += `> [P0-手术刀] D位=${r19.d}，指向[${r19.dir}]，基准分+10。\n`;

        // Algo 16 (P1) - 跳水状态下升级为 P0
        let p16_weight = isDiving ? 10 : 4;
        if (r16.dir === '大') w.big += p16_weight; else w.sml += p16_weight;
        if (isDiving) log += `> [状态触发] 极大差值(跳水)，Algo16 提权至 P0。\n`;

        // Algo 3 (P3) - 变盘预警
        if (r3.dir === '警(反)') {
            log += `> [警告] Algo3 触发变盘信号，所有惯性结论降权 50%！\n`;
            w.big *= 0.5; w.sml *= 0.5;
        } else if (r3.dir === '大') w.big += 3; else if (r3.dir === '小') w.sml += 3;

        // Algo 10 (P4) - 极值修正
        if (r10.dir === '反弹') {
            log += `> [修正] 极值处于反弹位(Dec=${r10.d})，防守反向。\n`;
            // 对冲逻辑
            if (w.big > w.sml) w.sml += 3; else w.big += 3; 
        }

        // Algo 14 (顺/裂)
        if (r14.dir === '同(顺)') {
            log += `> [顺势] Algo14 顺形态，建议顺势加仓。\n`;
            // 给当前最高分加分
            if (w.big > w.sml) w.big += 2; else w.sml += 2;
        } else {
            log += `> [裂变] Algo14 裂变形态，注意双向防守。\n`;
        }

        // 3. 最终判定
        let maxScore = Math.max(w.big, w.sml, w.odd, w.evn);
        let finalCmd = "--";
        let finalColor = "";
        
        if (w.big === maxScore) { finalCmd = "大"; finalColor = "red-t"; }
        else if (w.sml === maxScore) { finalCmd = "小"; finalColor = "green-t"; }
        else if (w.odd === maxScore) { finalCmd = "单"; finalColor = "red-t"; } // 单红双绿(PC28习惯)
        else { finalCmd = "双"; finalColor = "green-t"; }

        // 4. 战术路径生成 (第12段)
        let tactics = `\n【核心战术路径】\n`;
        tactics += `1. 主力压制: [${finalCmd}] (权重 ${maxScore})\n`;
        tactics += `2. 防御拦截: [${r10.dir==='反弹'?'反向对冲':'算法10震荡'}]\n`;
        tactics += `3. 资金建议: ${maxScore > 15 ? '重拳出击' : '猥琐发育'}\n`;

        // --- 渲染 UI ---
        
        // 核心圆盘
        const domRes = document.getElementById('finalRes');
        domRes.innerText = finalCmd;
        domRes.className = `res-text ${finalColor}`;
        document.getElementById('finalConf').innerText = `Confidence: ${Math.min(99, maxScore*4)}%`;

        // 积分板
        document.getElementById('sBig').innerText = w.big;
        document.getElementById('sSml').innerText = w.sml;
        document.getElementById('sOdd').innerText = w.odd;
        document.getElementById('sEvn').innerText = w.evn;

        // 算法矩阵表
        const tbody = document.getElementById('matrixBody');
        tbody.innerHTML = '';
        matrix.forEach(m => {
            tbody.innerHTML += `<tr>
                <td>Algo ${m.id}</td>
                <td>${typeof m.d === 'number' ? m.d : m.d}</td>
                <td style="font-weight:bold">${m.dir}</td>
                <td>${m.p}</td>
            </tr>`;
        });

        // 深度解析
        document.getElementById('analysisBox').innerText = log + tactics;

        // 历史列表
        const histDiv = document.getElementById('historyList');
        histDiv.innerHTML = CONFIG.history.slice().reverse().map(h => {
            let s = h.sum;
            let bs = s >= 14 ? '大' : '小';
            let oe = s % 2 !== 0 ? '单' : '双';
            return `<div class="history-row">
                <span style="color:#888">${h.q.slice(-4)}期</span>
                <span style="font-family:monospace; font-weight:700">${h.n1}+${h.n2}+${h.n3}=${h.sum}</span>
                <div>
                    <span class="badge ${bs==='大'?'b-red':'b-green'}">${bs}</span>
                    <span class="badge ${oe==='单'?'b-red':'b-green'}">${oe}</span>
                </div>
            </div>`;
        }).join('');
    }

    // --- 倒计时逻辑 ---
    function resetTimer() {
        CONFIG.count = CONFIG.refreshInterval;
        if (CONFIG.timer) clearInterval(CONFIG.timer);
        CONFIG.timer = setInterval(() => {
            CONFIG.count--;
            document.getElementById('nextTimer').innerText = CONFIG.count + 's';
            document.getElementById('progressBar').style.width = (100 - (CONFIG.count/CONFIG.refreshInterval)*100) + '%';
            if (CONFIG.count <= 0) {
                fetchData();
            }
        }, 1000);
    }

    // --- 启动 ---
    window.onload = () => {
        fetchData();
    };

</script>
</body>
</html>
